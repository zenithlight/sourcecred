// @flow

import {type URL} from "../../core/references";
import {type TimestampMs} from "../../util/timestamp";
import {findDuplicates} from "../../util/findDuplicates";
import {
  type NodeEntry,
  type NodeEntryJson,
  normalizeNodeEntry,
} from "./nodeEntry";

/**
 * A type which supports multiple ways of defining what edges an Initiative has.
 * Currently includes reference detected URLs and NodeEntries.
 * This is the normalized variant of EdgeSpecJson.
 */
export type EdgeSpec = {|
  +urls: $ReadOnlyArray<URL>,
  +entries: $ReadOnlyArray<NodeEntry>,
|};

// A type with convenient default values for users to manually enter.
// Should be inexact Flow type as with JSON sources you never know.
export type EdgeSpecJson = $Shape<{
  // Defaults to an empty array.
  +urls: $ReadOnlyArray<URL>,
  // Defaults to an empty array.
  +entries: $ReadOnlyArray<NodeEntryJson>,
}>;

/**
 * Takes an EdgeSpecJson and normalizes it to an EdgeSpec.
 *
 * Will throw when required fields are missing or duplicate keys are found.
 * Otherwise handles default values and converting ISO timestamps.
 * Note: we allow the EdgeSpecJson to be undefined to easily support omitting
 * edges entirely, while still normalizing to an EdgeSpec.
 */
export function normalizeEdgeSpec(
  spec: ?EdgeSpecJson,
  defaultTimestampMs: TimestampMs
): EdgeSpec {
  const {urls, entries} = spec || {};
  return _validateEdgeSpec({
    urls: urls || [],
    entries: (entries || []).map((x: NodeEntryJson) =>
      normalizeNodeEntry(x, defaultTimestampMs)
    ),
  });
}

/**
 * A separate function to validate an EdgeSpec after it's normalized.
 * Normally you don't need to invoke this directly.
 */
export function _validateEdgeSpec(spec: EdgeSpec): EdgeSpec {
  const duplicates = _findDuplicatesByKey(spec.entries);
  if (duplicates.size) {
    // The keys are duplicate and often generated by the normalize functions.
    // So we need to offer more details to identify the duplicate entries.
    const dupeList = Array.from(duplicates)
      .map((e) => JSON.stringify(e))
      .join("\n  ");
    throw new Error(
      `Duplicate entry keys are not allowed, you may need to ` +
        `set keys manually for:\n  ${dupeList}`
    );
  }
  return spec;
}

/**
 * Find the NodeEntries which have a duplicate key.
 */
export function _findDuplicatesByKey(
  entries: $ReadOnlyArray<NodeEntry>
): Set<NodeEntry> {
  const duplicateKeys = findDuplicates(entries.map((e) => e.key));
  // Having a set of keys is useful, but we want to know where these keys came from.
  // Include all entries with a key that produces duplicates, even the first one.
  return new Set(entries.filter((e) => duplicateKeys.has(e.key)));
}
